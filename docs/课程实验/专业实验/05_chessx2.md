---


title: 象棋的设计(4):搜索算法
date: '2022-05-24 11:28'

---
::: tip 摘要
这一节介绍棋子的搜索算法

:::

## 局面评估

局面评估，就是判断局面对红方（或黑方）的优势，并把优势量化。棋子价值可用以下不等式表达：

帅 > 车 > 马、炮 > 仕、相 > 兵

棋子价值可以简单量化为：

|  兵  |  仕  |  相  |  炮  |  马  |  车  |  帅  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  10  |  20  |  20  |  40  |  45  |  90  | 1000 |

::: tip
但是棋子价值是跟位置有关系的，比如兵在过河前价值很小，过河后价值大涨。在我的程序中，就不考虑这个了。
:::

## 搜索算法
思路：轮到电脑方执棋时:

1. 电脑先计算求出所有红方可能走的棋子，选出对红方最有利的走法。
2. 然后电脑得知了红方下一步最有可能怎么走。
3. 电脑计算求出所有它可以走的棋子，找出能阻断破坏上述对红方最有利的走法、或对自己黑方最有利的走法。
4. 比如红方将军，轮到电脑执棋时，电脑会检索到红方将军这一步走法，然后尝试阻断这一将军；而在没有将军时，电脑也会尝试去吃掉红方价值最大的棋子。
``` mermaid
flowchart TD
    A["开始"]
    B(["先定义一个变量maxVal，
    然后遍历红方棋子
    (每次遍历的元素：红棋item1)"])
    C(["使用machine_getExactStep(item1)
    函数得到item1的最佳走法[sqSrc,sqDst]"])
    C1(["使用machine_evaluate(arr)函数
    求出当前棋盘的价值，其中参数arr为当前
    棋盘数组；结果保存在val1"])
	D{val1 > maxVal?}
    E(["记录当前最大评估值: maxVal=val1;
    记录此时的起点: sqSrc_w = sqSrc"])
    F{"是否遍历完红棋？"}
    G[("此时电脑已计算出红方
    最有可能走的棋子，即sqSrc_w")]
    
    J(["初始化一个变量minVal = maxVal,
    遍历黑棋（item2）"])
    K(["遍历黑棋item2的所有走法(item3)"])
    L(["电脑内部模拟黑棋使
    用了走法item3([sqSrc,sqDst])"])
    M(["重新使用machine_getExactStep(item3)
    函数得到红棋sqSrc_w的最佳走法[sqSrc_w,sqDst]"])
    N(["电脑内部模拟该红棋按最佳走法落子"])
    O(["调用machine_evaluate(arr)
    函数计算此时内部模拟棋盘的价值，
    其中参数arr为模拟棋盘数组;结果保存在val2中"])
    P{val2 < minVal?}
    Q(["记录当前最小评估值: maxVal=val1;
    记录此时的起点: sqSrc_b = sqSrc
    记录此时的终点sqDst_b = sqDst"])
    R{"是否遍历完该黑棋的走法？"}
    S{"是否遍历完所有黑棋？"}
    T[("此时电脑计算
    出对它最有利的走法[sqSrc_b,sqDst_b]")]
    
    A --> B --> C --> C1 --> D
    D ---->|no| B
    D -->|yes| E --> F
	F -->|no| B
	F -->|yes|G
	G --> J --> K --> L --> M --> N --> O --> P
	P -->|no|L 
	P -->|yes| Q --> R
	R -->|no|K
	R -->|yes|S
	S -->|no|J
	S -->|yes|T
```

